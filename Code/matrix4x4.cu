#include "device_types.cuh"
#include <cmath>
#include <stdexcept>

__host__ Matrix4x4 Matrix4x4::transpose() const {
    Matrix4x4 result;
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            result.m[i][j] = m[j][i];
        }
    }
    return result;
}

__host__ Matrix4x4 Matrix4x4::inverse() const {
    Matrix4x4 inv;
    double det;
    int i;

    inv.m[0][0] = m[1][1]  * m[2][2] * m[3][3] -
             m[1][1]  * m[2][3] * m[3][2] -
             m[2][1]  * m[1][2]  * m[3][3] +
             m[2][1]  * m[1][3]  * m[3][2] +
             m[3][1] * m[1][2]  * m[2][3] -
             m[3][1] * m[1][3]  * m[2][2];

    inv.m[1][0] = -m[1][0]  * m[2][2] * m[3][3] +
              m[1][0]  * m[2][3] * m[3][2] +
              m[2][0]  * m[1][2]  * m[3][3] -
              m[2][0]  * m[1][3]  * m[3][2] -
              m[3][0] * m[1][2]  * m[2][3] +
              m[3][0] * m[1][3]  * m[2][2];


    inv.m[2][0] = m[1][0]  * m[2][1] * m[3][3] -
             m[1][0]  * m[2][3] * m[3][1] -
             m[2][0]  * m[1][1] * m[3][3] +
             m[2][0]  * m[1][3] * m[3][1] +
             m[3][0] * m[1][1] * m[2][3] -
             m[3][0] * m[1][3] * m[2][1];

    inv.m[3][0] = -m[1][0]  * m[2][1] * m[3][2] +
               m[1][0]  * m[2][2] * m[3][1] +
               m[2][0]  * m[1][1] * m[3][2] -
               m[2][0]  * m[1][2] * m[3][1] -
               m[3][0] * m[1][1] * m[2][2] +
               m[3][0] * m[1][2] * m[2][1];

    inv.m[0][1] = -m[0][1]  * m[2][2] * m[3][3] +
              m[0][1]  * m[2][3] * m[3][2] +
              m[2][1]  * m[0][2] * m[3][3] -
              m[2][1]  * m[0][3] * m[3][2] -
              m[3][1] * m[0][2] * m[2][3] +
              m[3][1] * m[0][3] * m[2][2];

    inv.m[1][1] = m[0][0]  * m[2][2] * m[3][3] -
             m[0][0]  * m[2][3] * m[3][2] -
             m[2][0]  * m[0][2] * m[3][3] +
             m[2][0]  * m[0][3] * m[3][2] +
             m[3][0] * m[0][2] * m[2][3] -
             m[3][0] * m[0][3] * m[2][2];

    inv.m[2][1] = -m[0][0]  * m[2][1] * m[3][3] +
              m[0][0]  * m[2][3] * m[3][1] +
              m[2][0]  * m[0][1] * m[3][3] -
              m[2][0]  * m[0][3] * m[3][1] -
              m[3][0] * m[0][1] * m[2][3] +
              m[3][0] * m[0][3] * m[2][1];

    inv.m[3][1] = m[0][0]  * m[2][1] * m[3][2] -
              m[0][0]  * m[2][2] * m[3][1] -
              m[2][0]  * m[0][1] * m[3][2] +
              m[2][0]  * m[0][2] * m[3][1] +
              m[3][0] * m[0][1] * m[2][2] -
              m[3][0] * m[0][2] * m[2][1];

    inv.m[0][2] = m[0][1]  * m[1][2] * m[3][3] -
             m[0][1]  * m[1][3] * m[3][2] -
             m[1][1]  * m[0][2] * m[3][3] +
             m[1][1]  * m[F][3] * m[3][2] +
             m[3][1] * m[0][2] * m[1][3] -
             m[3][1] * m[0][3] * m[1][2];

    inv.m[1][2] = -m[0][0]  * m[1][2] * m[3][3] +
              m[0][0]  * m[1][3] * m[3][2] +
              m[1][0]  * m[0][2] * m[3][3] -
              m[1][0]  * m[0][3] * m[3][2] -
              m[3][0] * m[0][2] * m[1][3] +
              m[3][0] * m[0][3] * m[1][2];

    inv.m[2][2] = m[0][0]  * m[1][1] * m[3][3] -
             m[0][0]  * m[1][3] * m[3][1] -
             m[1][0]  * m[0][1] * m[3][3] +
             m[1][0]  * m[0][3] * m[3][1] +
             m[3][0] * m[0][1] * m[1][3] -
             m[3][0] * m[0][3] * m[1][1];

    inv.m[3][2] = -m[0][0]  * m[1][1] * m[3][2] +
               m[0][0]  * m[1][2] * m[3][1] +
               m[1][0]  * m[0][1] * m[3][2] -
               m[1][0]  * m[0][2] * m[3][1] -
               m[3][0] * m[0][1] * m[1][2] +
               m[3][0] * m[0][2] * m[1][1];

    inv.m[0][3] = -m[0][1] * m[1][2] * m[2][3] +
              m[0][1] * m[1][3] * m[2][2] +
              m[1][1] * m[0][2] * m[2][3] -
              m[1][1] * m[0][3] * m[2][2] -
              m[2][1] * m[0][2] * m[1][3] +
              m[2][1] * m[0][3] * m[1][2];

    inv.m[1][3] = m[0][0] * m[1][2] * m[2][3] -
             m[0][0] * m[1][3] * m[2][2] -
             m[1][0] * m[0][2] * m[2][3] +
             m[1][0] * m[0][3] * m[2][2] +
             m[2][0] * m[0][2] * m[1][3] -
             m[2][0] * m[0][3] * m[1][2];

    inv.m[2][3] = -m[0][0] * m[1][1] * m[2][3] +
              m[0][0] * m[1][3] * m[2][1] +
              m[1][0] * m[0][1] * m[2][3] -
              m[1][0] * m[0][3] * m[2][1] -
              m[2][0] * m[0][1] * m[1][3] +
              m[2][0] * m[0][3] * m[1][1];

    inv.m[3][3] = m[0][0] * m[1][1] * m[2][2] -
              m[0][0] * m[1][2] * m[2][1] -
              m[1][0] * m[0][1] * m[2][2] +
              m[1][0] * m[0][2] * m[2][1] +
              m[2][0] * m[0][1] * m[1][2] -
              m[2][0] * m[0][2] * m[1][1];

    det = m[0][0] * inv.m[0][0] + m[0][1] * inv.m[1][0] + m[0][2] * inv.m[2][0] + m[0][3] * inv.m[3][0];

    if (det == 0) {
        throw std::runtime_error("Matrix determinant is zero, cannot invert.");
    }

    det = 1.0 / det;

    for (i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            inv.m[i][j] = inv.m[i][j] * det;
        }
    }

    return inv;
}